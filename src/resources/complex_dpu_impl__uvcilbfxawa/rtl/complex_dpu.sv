// This file was automatically generated by Vesyla. DO NOT EDIT.

`define complex_dpu_impl _uvcilbfxawa

module _uvcilbfxawa
import _uvcilbfxawa_pkg::*;
(
    input  logic clk_0,
    input  logic rst_n_0,
    input  logic instr_en_0,
    input  logic [RESOURCE_INSTR_WIDTH-1:0] instr_0,
    input  logic [3:0] activate_0,
    input  logic [WORD_BITWIDTH-1:0] word_data_in_0,
    output logic [WORD_BITWIDTH-1:0] word_data_out_0,
    input  logic [BULK_BITWIDTH-1:0] bulk_data_in_0,
    output logic [BULK_BITWIDTH-1:0] bulk_data_out_0,
    input  logic clk_1,
    input  logic rst_n_1,
    input  logic instr_en_1,
    input  logic [RESOURCE_INSTR_WIDTH-1:0] instr_1,
    input  logic [3:0] activate_1,
    input  logic [WORD_BITWIDTH-1:0] word_data_in_1,
    output logic [WORD_BITWIDTH-1:0] word_data_out_1,
    input  logic [BULK_BITWIDTH-1:0] bulk_data_in_1,
    output logic [BULK_BITWIDTH-1:0] bulk_data_out_1
);

    logic clk, rst_n, instruction_valid, activate;
    logic [RESOURCE_INSTR_WIDTH-1:0] instruction;
    assign clk = clk_0;
    assign rst_n = rst_n_0;
    assign instruction_valid = instr_en_0;
    assign activate = activate_0[0];
    assign instruction = instr_0;

    // useless output
    assign word_data_out_1 = 0;
    assign bulk_data_out_0 = 0;
    assign bulk_data_out_1 = 0;

    // register inputs
    logic [WORD_BITWIDTH-1:0] in0, in1, out0;
    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            in0 <= 0;
            in1 <= 0;
        end else begin
            in0 <= word_data_in_0;
            in1 <= word_data_in_1;
        end
    end

    logic [$clog2(FSM_MAX_STATES)-1:0][DPU_MODE_WIDTH-1:0] mode_memory;
    logic [$clog2(FSM_MAX_STATES)-1:0][DPU_IMMEDIATE_WIDTH-1:0] immediate_memory;
    logic [$clog2(FSM_MAX_STATES)-1:0] fsm_option;
    logic [$clog2(FSM_MAX_STATES)-1:0] fsm_max_init_state;
    logic [FSM_MAX_STATES-2:0][FSM_DELAY_WIDTH-1:0] fsm_delays;
    logic [DPU_IMMEDIATE_WIDTH-1:0] immediate;
    logic [DPU_MODE_WIDTH-1:0] mode;
    logic [OPCODE_WIDTH-1:0] opcode;
    logic dpu_valid;
    logic fsm_valid;

    dpu_t dpu;
    fsm_t fsm;

    fsm #(
        .FSM_MAX_STATES(FSM_MAX_STATES),
        .FSM_DELAY_WIDTH(FSM_DELAY_WIDTH)
    ) fsm_inst (
        .clk(clk),
        .rst_n(rst_n),
        .activate(|activate),
        .fsm_delays(fsm_delays),
        .max_init_state(fsm_max_init_state),
        .state(fsm_option)
    );

    assign opcode = instruction[OPCODE_H:OPCODE_L];
    assign dpu_valid = instruction_valid && (opcode == OPCODE_DPU);
    assign fsm_valid = instruction_valid && (opcode == OPCODE_FSM);
    assign dpu = dpu_valid ? unpack_dpu(
            instruction[INSTRUCTION_PAYLOAD_WIDTH-1:0]
        ) :
        '{default: 0};
    assign fsm = fsm_valid ? unpack_fsm(
            instruction[INSTRUCTION_PAYLOAD_WIDTH-1:0]
        ) :
        '{default: 0};
  
    always_ff @(posedge clk or negedge rst_n) begin
      if (!rst_n) begin
        immediate_memory <= '0;
        mode_memory <= '0;
        fsm_max_init_state <= '0;
      end else begin
        if (dpu_valid) begin
          mode_memory[dpu._option] <= dpu._mode;
          immediate_memory[dpu._option] <= dpu._immediate;
          fsm_max_init_state <= dpu._option;
        end
      end
    end

    // TODO: we need to make the number of delays parametric somehow
    assign fsm_delays[0] = fsm._delay_0;
    assign fsm_delays[1] = fsm._delay_1;
    assign fsm_delays[2] = fsm._delay_2;

    assign mode = mode_memory[fsm_option];
    assign immediate = immediate_memory[fsm_option];

    logic signed [WORD_BITWIDTH-1:0] adder_in0;
    logic signed [WORD_BITWIDTH-1:0] adder_in1;
    logic signed [WORD_BITWIDTH-1:0] adder_out;
    logic signed [WORD_BITWIDTH-1:0] mult_in0;
    logic signed [WORD_BITWIDTH-1:0] mult_in1;
    logic signed [WORD_BITWIDTH-1:0] mult_out;

    always_comb begin
        out0 = 0;
        adder_in0 = 0;
        adder_in1 = 0;
        mult_in0 = 0;
        mult_in1 = 0;

        case (mode)
            DPU_MODE_ADD: begin
                adder_in0 = in0;
                adder_in1 = in1;
                out0 = adder_out;
            end
            DPU_MODE_MUL: begin
                mult_in0 = in0;
                mult_in1 = in1;
                out0 = mult_out;
            end
        endcase
    end

    adder adder_inst (
        .data_in0(adder_in0),
        .data_in1(adder_in1),
        .data_out(adder_out)
    );

    multiplier mult_inst (
        .data_in0(mult_in0),
        .data_in1(mult_in1),
        .data_out(mult_out)
    );

    assign word_data_out_0 = out0;

endmodule