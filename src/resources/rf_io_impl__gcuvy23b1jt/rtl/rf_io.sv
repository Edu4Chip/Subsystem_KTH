// This file was automatically generated by Vesyla. DO NOT EDIT.

`define rf_io_impl _gcuvy23b1jt
`define rf_io_impl_pkg _gcuvy23b1jt_pkg

package _gcuvy23b1jt_pkg;
    parameter BULK_ADDR_WIDTH = 3;
    parameter BULK_BITWIDTH = 256;
    parameter FSM_PER_SLOT = 4;
    parameter INSTR_OPCODE_BITWIDTH = 3;
    parameter IO_ADDR_WIDTH = 2;
    parameter IO_DATA_WIDTH = 256;
    parameter NUM_SLOTS = 16;
    parameter RESOURCE_INSTR_WIDTH = 27;
    parameter RF_DEPTH = 64;
    parameter WORD_ADDR_WIDTH = 6;
    parameter WORD_BITWIDTH = 32;
    parameter AGU_BITWIDTH = 16;
    parameter DELAY_WIDTH = 5;

    typedef struct packed {
        logic _init_addr_sd;
        logic [15:0] _init_addr;
        logic [1:0] _port;
    } dsu_t;

    function static dsu_t unpack_dsu;
        input logic [23:0] instr;
        dsu_t _dsu;
        _dsu._init_addr_sd = instr[23];
        _dsu._init_addr  = instr[22:7];
        _dsu._port  = instr[6:5];
        return _dsu;
    endfunction

    function static logic [23:0] pack_dsu;
        input dsu_t _dsu;
        logic [23:0] instr;

        instr[23] = _dsu._init_addr_sd;
        instr[22:7] = _dsu._init_addr;
        instr[6:5] = _dsu._port;
        return instr;
    endfunction
    typedef struct packed {
        logic [1:0] _port;
        logic [3:0] _level;
        logic [5:0] _iter;
        logic [5:0] _step;
        logic [5:0] _delay;
    } rep_t;

    function static rep_t unpack_rep;
        input logic [23:0] instr;
        rep_t _rep;
        _rep._port  = instr[23:22];
        _rep._level  = instr[21:18];
        _rep._iter  = instr[17:12];
        _rep._step  = instr[11:6];
        _rep._delay  = instr[5:0];
        return _rep;
    endfunction

    function static logic [23:0] pack_rep;
        input rep_t _rep;
        logic [23:0] instr;

        instr[23:22] = _rep._port;
        instr[21:18] = _rep._level;
        instr[17:12] = _rep._iter;
        instr[11:6] = _rep._step;
        instr[5:0] = _rep._delay;
        return instr;
    endfunction
    typedef struct packed {
        logic [1:0] _port;
        logic [3:0] _level;
        logic [5:0] _iter;
        logic [5:0] _step;
        logic [5:0] _delay;
    } repx_t;

    function static repx_t unpack_repx;
        input logic [23:0] instr;
        repx_t _repx;
        _repx._port  = instr[23:22];
        _repx._level  = instr[21:18];
        _repx._iter  = instr[17:12];
        _repx._step  = instr[11:6];
        _repx._delay  = instr[5:0];
        return _repx;
    endfunction

    function static logic [23:0] pack_repx;
        input repx_t _repx;
        logic [23:0] instr;

        instr[23:22] = _repx._port;
        instr[21:18] = _repx._level;
        instr[17:12] = _repx._iter;
        instr[11:6] = _repx._step;
        instr[5:0] = _repx._delay;
        return instr;
    endfunction
    typedef struct packed {
        logic [1:0] _port;
        logic [11:0] _n_points;
        logic [1:0] _radix;
        logic _n_bu;
        logic _mode;
        logic [5:0] _delay;
    } fft_t;

    function static fft_t unpack_fft;
        input logic [23:0] instr;
        fft_t _fft;
        _fft._port  = instr[23:22];
        _fft._n_points  = instr[21:10];
        _fft._radix  = instr[9:8];
        _fft._n_bu = instr[7];
        _fft._mode = instr[6];
        _fft._delay  = instr[5:0];
        return _fft;
    endfunction

    function static logic [23:0] pack_fft;
        input fft_t _fft;
        logic [23:0] instr;

        instr[23:22] = _fft._port;
        instr[21:10] = _fft._n_points;
        instr[9:8] = _fft._radix;
        instr[7] = _fft._n_bu;
        instr[6] = _fft._mode;
        instr[5:0] = _fft._delay;
        return instr;
    endfunction


endpackage

module _gcuvy23b1jt
import _gcuvy23b1jt_pkg::*;
(
    input  logic clk_0,
    input  logic rst_n_0,
    input  logic instr_en_0,
    input  logic [RESOURCE_INSTR_WIDTH-1:0] instr_0,
    input  logic [3:0] activate_0,
    input  logic [WORD_BITWIDTH-1:0] word_data_in_0,
    output logic [WORD_BITWIDTH-1:0] word_data_out_0,
    input  logic [BULK_BITWIDTH-1:0] bulk_data_in_0,
    output logic [BULK_BITWIDTH-1:0] bulk_data_out_0,
    input  logic clk_1,
    input  logic rst_n_1,
    input  logic instr_en_1,
    input  logic [RESOURCE_INSTR_WIDTH-1:0] instr_1,
    input  logic [3:0] activate_1,
    input  logic [WORD_BITWIDTH-1:0] word_data_in_1,
    output logic [WORD_BITWIDTH-1:0] word_data_out_1,
    input  logic [BULK_BITWIDTH-1:0] bulk_data_in_1,
    output logic [BULK_BITWIDTH-1:0] bulk_data_out_1,
    input  logic clk_2,
    input  logic rst_n_2,
    input  logic instr_en_2,
    input  logic [RESOURCE_INSTR_WIDTH-1:0] instr_2,
    input  logic [3:0] activate_2,
    input  logic [WORD_BITWIDTH-1:0] word_data_in_2,
    output logic [WORD_BITWIDTH-1:0] word_data_out_2,
    input  logic [BULK_BITWIDTH-1:0] bulk_data_in_2,
    output logic [BULK_BITWIDTH-1:0] bulk_data_out_2,
    input  logic clk_3,
    input  logic rst_n_3,
    input  logic instr_en_3,
    input  logic [RESOURCE_INSTR_WIDTH-1:0] instr_3,
    input  logic [3:0] activate_3,
    input  logic [WORD_BITWIDTH-1:0] word_data_in_3,
    output logic [WORD_BITWIDTH-1:0] word_data_out_3,
    input  logic [BULK_BITWIDTH-1:0] bulk_data_in_3,
    output logic [BULK_BITWIDTH-1:0] bulk_data_out_3,
    output logic io_en_in,
    output logic [IO_ADDR_WIDTH-1:0] io_addr_in,
    input  logic [IO_DATA_WIDTH-1:0] io_data_in,
    output logic io_en_out,
    output logic [IO_ADDR_WIDTH-1:0] io_addr_out,
    output logic [IO_DATA_WIDTH-1:0] io_data_out
);

    // Useless outputs:
    assign word_data_out_0 = 0;
    assign bulk_data_out_0 = 0;
    assign bulk_data_out_1 = 0;
    assign bulk_data_out_2 = 0;
    assign bulk_data_out_3 = 0;

    logic clk, rst_n;
    assign clk = clk_0;
    assign rst_n = rst_n_0;

    logic [INSTR_OPCODE_BITWIDTH-1:0] opcode_0, opcode_1, opcode_3;
    logic [RESOURCE_INSTR_WIDTH-INSTR_OPCODE_BITWIDTH-1:0] payload_0, payload_1, payload_3;

    assign opcode_0 = instr_0[RESOURCE_INSTR_WIDTH-1:RESOURCE_INSTR_WIDTH-INSTR_OPCODE_BITWIDTH];
    assign payload_0 = instr_0[RESOURCE_INSTR_WIDTH-INSTR_OPCODE_BITWIDTH-1:0];
    assign opcode_1 = instr_1[RESOURCE_INSTR_WIDTH-1:RESOURCE_INSTR_WIDTH-INSTR_OPCODE_BITWIDTH];
    assign payload_1 = instr_1[RESOURCE_INSTR_WIDTH-INSTR_OPCODE_BITWIDTH-1:0];
    assign opcode_3 = instr_3[RESOURCE_INSTR_WIDTH-1:RESOURCE_INSTR_WIDTH-INSTR_OPCODE_BITWIDTH];
    assign payload_3 = instr_3[RESOURCE_INSTR_WIDTH-INSTR_OPCODE_BITWIDTH-1:0];
    
    dsu_t dsu_0;
    rep_t rep_0;
    repx_t repx_0;
    fft_t fft_1, fft_3;

    logic dsu_valid_0;
    logic rep_valid_0;
    logic repx_valid_0;
    logic fft_valid_1, fft_valid_3;

    assign dsu_valid_0 = instr_en_0 && (opcode_0 == 6);
    assign rep_valid_0 = instr_en_0 && (opcode_0 == 0);
    assign repx_valid_0 = instr_en_0 && (opcode_0 == 1);
    assign dsu_0 = dsu_valid_0 ? unpack_dsu(payload_0) : '{default: 0};
    assign rep_0 = rep_valid_0 ? unpack_rep(payload_0) : '{default: 0};
    assign repx_0 = repx_valid_0 ? unpack_repx(payload_0) : '{default: 0};

    assign fft_valid_1 = instr_en_1 && (opcode_1 == 4);
    assign fft_1 = fft_valid_1 ? unpack_fft(payload_1) : '{default: 0};

    assign fft_valid_3 = instr_en_3 && (opcode_3 == 4);
    assign fft_3 = fft_valid_3 ? unpack_fft(payload_3) : '{default: 0};

    logic [IO_ADDR_WIDTH-1:0] addr_0_0, addr_0_1;
    logic [AGU_BITWIDTH-1:0] addr_0_2, addr_0_3;
    logic port_enable_0_0, port_enable_0_1, port_enable_0_2, port_enable_0_3;

    logic [AGU_BITWIDTH-1:0] addr_1_0, addr_1_1;
    logic port_enable_1_0, port_enable_1_1;

    logic [AGU_BITWIDTH-1:0] addr_2_0, addr_2_1;
    logic port_enable_2_0, port_enable_2_1;

    logic [AGU_BITWIDTH-1:0] addr_3_1;
    logic port_enable_3_1;

    logic [IO_ADDR_WIDTH-1:0] step_0_0;
    logic [IO_ADDR_WIDTH-1:0] delay_0_0;
    logic [IO_ADDR_WIDTH-1:0] iter_0_0;
    logic [IO_ADDR_WIDTH-1:0] init_addr_0_0;
    logic [IO_ADDR_WIDTH-1:0] step_0_1;
    logic [IO_ADDR_WIDTH-1:0] delay_0_1;
    logic [IO_ADDR_WIDTH-1:0] iter_0_1;
    logic [IO_ADDR_WIDTH-1:0] init_addr_0_1;
    logic [AGU_BITWIDTH-1:0] step_0_2;
    logic [AGU_BITWIDTH-1:0] delay_0_2;
    logic [AGU_BITWIDTH-1:0] iter_0_2;
    logic [AGU_BITWIDTH-1:0] init_addr_0_2;
    logic [AGU_BITWIDTH-1:0] step_0_3;
    logic [AGU_BITWIDTH-1:0] delay_0_3;
    logic [AGU_BITWIDTH-1:0] iter_0_3;
    logic [AGU_BITWIDTH-1:0] init_addr_0_3;

    logic [DELAY_WIDTH-1:0] delay_1_0, delay_1_1;
    logic [AGU_BITWIDTH-1:0] n_points_1_0, n_points_1_1;
    logic [1:0] radix_1_0, radix_1_1;
    logic n_bu_1_0, n_bu_1_1;
    logic mode_1_0, mode_1_1;

    logic [DELAY_WIDTH-1:0] delay_2_0, delay_2_1;
    logic [AGU_BITWIDTH-1:0] n_points_2_0, n_points_2_1;
    logic [1:0] radix_2_0, radix_2_1;
    logic n_bu_2_0, n_bu_2_1;
    logic mode_2_0, mode_2_1;

    logic [DELAY_WIDTH-1:0] delay_3_1;
    logic [AGU_BITWIDTH-1:0] n_points_3_1;
    logic [1:0] radix_3_1;
    logic n_bu_3_1;
    logic mode_3_1;
    
    assign step_0_0 = rep_0._step;
    assign delay_0_0 = rep_0._delay;
    assign iter_0_0 = rep_0._iter;
    assign init_addr_0_0 = dsu_0._init_addr;
    assign step_0_1 = rep_0._step;
    assign delay_0_1 = rep_0._delay;
    assign iter_0_1 = rep_0._iter;
    assign init_addr_0_1 = dsu_0._init_addr;
    assign step_0_2 = rep_0._step;
    assign delay_0_2 = rep_0._delay;
    assign iter_0_2 = rep_0._iter;
    assign init_addr_0_2 = dsu_0._init_addr;
    assign step_0_3 = rep_0._step;
    assign delay_0_3 = rep_0._delay;
    assign iter_0_3 = rep_0._iter;
    assign init_addr_0_3 = dsu_0._init_addr;

    assign n_points_1_0 = fft_1._n_points;
    assign radix_1_0 = fft_1._radix;
    assign mode_1_0 = fft_1._mode;
    assign n_bu_1_0 = fft_1._n_bu;
    assign delay_1_0 = fft_1._delay;
    assign n_points_1_1 = fft_1._n_points;
    assign radix_1_1 = fft_1._radix;
    assign mode_1_1 = fft_1._mode;
    assign n_bu_1_1 = fft_1._n_bu;
    assign delay_1_1 = fft_1._delay;

    assign n_points_2_0 = fft_1._n_points;
    assign radix_2_0 = fft_1._radix;
    assign mode_2_0 = fft_1._mode;
    assign n_bu_2_0 = fft_1._n_bu;
    assign delay_2_0 = fft_1._delay;
    assign n_points_2_1 = fft_1._n_points;
    assign radix_2_1 = fft_1._radix;
    assign mode_2_1 = fft_1._mode;
    assign n_bu_2_1 = fft_1._n_bu;
    assign delay_2_1 = fft_1._delay;

    assign n_points_3_1 = fft_3._n_points;
    assign radix_3_1 = fft_3._radix;
    assign mode_3_1 = fft_3._mode;
    assign n_bu_3_1 = fft_3._n_bu;
    assign delay_3_1 = fft_3._delay;
    
    agu #(
        .ADDRESS_WIDTH(IO_ADDR_WIDTH),
        .NUMBER_OF_LEVELS(4)
    ) agu_0_0 (
        .clk(clk),
        .rst_n(rst_n),
        .activate(activate_0[0]),
        .load_initial(dsu_valid_0 & dsu_0._port == 0),
        .load_level(rep_valid_0 & rep_0._port == 0),
        .is_extended(),  // TODO: not supported yet
        .level_to_load(rep_0._level[1:0]),
        .step(step_0_0),
        .delay(delay_0_0),
        .iterations(iter_0_0),
        .initial_address(init_addr_0_0),
        .address_valid(port_enable_0_0),
        .address(addr_0_0)
    );

    agu #(
        .ADDRESS_WIDTH(IO_ADDR_WIDTH),
        .NUMBER_OF_LEVELS(4)
    ) agu_0_1 (
        .clk(clk),
        .rst_n(rst_n),
        .activate(activate_0[1]),
        .load_initial(dsu_valid_0 & dsu_0._port == 1),
        .load_level(rep_valid_0 & rep_0._port == 1),
        .is_extended(),  // TODO: not supported yet
        .level_to_load(rep_0._level[1:0]),
        .step(step_0_1),
        .delay(delay_0_1),
        .iterations(iter_0_1),
        .initial_address(init_addr_0_1),
        .address_valid(port_enable_0_1),
        .address(addr_0_1)
    );

    agu #(
        .ADDRESS_WIDTH(AGU_BITWIDTH),
        .NUMBER_OF_LEVELS(4)
    ) agu_0_2 (
        .clk(clk),
        .rst_n(rst_n),
        .activate(activate_0[2]),
        .load_initial(dsu_valid_0 & dsu_0._port == 2),
        .load_level(rep_valid_0 & rep_0._port == 2),
        .is_extended(),  // TODO: not supported yet
        .level_to_load(rep_0._level[1:0]),
        .step(step_0_2),
        .delay(delay_0_2),
        .iterations(iter_0_2),
        .initial_address(init_addr_0_2),
        .address_valid(port_enable_0_2),
        .address(addr_0_2)
    );

    agu #(
        .ADDRESS_WIDTH(AGU_BITWIDTH),
        .NUMBER_OF_LEVELS(4)
    ) agu_0_3 (
        .clk(clk),
        .rst_n(rst_n),
        .activate(activate_0[3]),
        .load_initial(dsu_valid_0 & dsu_0._port == 3),
        .load_level(rep_valid_0 & rep_0._port == 3),
        .is_extended(),  // TODO: not supported yet
        .level_to_load(rep_0._level[1:0]),
        .step(step_0_3),
        .delay(delay_0_3),
        .iterations(iter_0_3),
        .initial_address(init_addr_0_3),
        .address_valid(port_enable_0_3),
        .address(addr_0_3)
    );

    agu_fft #(
        .AGU_BITWIDTH(AGU_BITWIDTH),
        .DELAY_WIDTH(DELAY_WIDTH)
    ) agu_1_0 (
        .clk(clk),
        .rst_n(rst_n),
        .activate(activate_1[0]),
        .radix(radix_1_0),
        .even_odd(1'b0),
        .mode(mode_1_0),
        .n_bu(n_bu_1_0),
        .bu_index(1'b0),
        .n_points(n_points_1_0),
        .delay(delay_1_0),
        .load_config(fft_valid_1 & fft_1._port == 0),
        .address_valid(port_enable_1_0),
        .address(addr_1_0)
    );

    agu_fft #(
        .AGU_BITWIDTH(AGU_BITWIDTH),
        .DELAY_WIDTH(DELAY_WIDTH)
    ) agu_1_1 (
        .clk(clk),
        .rst_n(rst_n),
        .activate(activate_1[1]),
        .radix(radix_1_1),
        .even_odd(1'b0),
        .mode(mode_1_1),
        .n_bu(n_bu_1_1),
        .bu_index(1'b0),
        .n_points(n_points_1_1),
        .delay(delay_1_1),
        .load_config(fft_valid_1 & fft_1._port == 1),
        .address_valid(port_enable_1_1),
        .address(addr_1_1)
    );

    agu_fft #(
        .AGU_BITWIDTH(AGU_BITWIDTH),
        .DELAY_WIDTH(DELAY_WIDTH)
    ) agu_2_0 (
        .clk(clk),
        .rst_n(rst_n),
        .activate(activate_2[0]),
        .radix(radix_2_0),
        .even_odd(1'b1),
        .mode(mode_2_0),
        .n_bu(n_bu_2_0),
        .bu_index(1'b1),
        .n_points(n_points_2_0),
        .delay(delay_2_0),
        .load_config(fft_valid_1 & fft_1._port == 0),
        .address_valid(port_enable_2_0),
        .address(addr_2_0)
    );

    agu_fft #(
        .AGU_BITWIDTH(AGU_BITWIDTH),
        .DELAY_WIDTH(DELAY_WIDTH)
    ) agu_2_1 (
        .clk(clk),
        .rst_n(rst_n),
        .activate(activate_2[1]),
        .radix(radix_2_1),
        .even_odd(1'b1),
        .mode(mode_2_1),
        .n_bu(n_bu_2_1),
        .bu_index(1'b1),
        .n_points(n_points_2_1),
        .delay(delay_2_1),
        .load_config(fft_valid_1 & fft_1._port == 1),
        .address_valid(port_enable_2_1),
        .address(addr_2_1)
    );

    agu_fft #(
        .AGU_BITWIDTH(AGU_BITWIDTH),
        .DELAY_WIDTH(DELAY_WIDTH)
    ) agu_3_1 (
        .clk(clk),
        .rst_n(rst_n),
        .activate(activate_3[1]),
        .radix(radix_3_1),
        .even_odd(1'b0),
        .mode(mode_3_1),
        .n_bu(n_bu_3_1),
        .bu_index(1'b0),
        .n_points(n_points_3_1),
        .delay(delay_3_1),
        .load_config(fft_valid_3 & fft_3._port == 1),
        .address_valid(port_enable_3_1),
        .address(addr_3_1)
    );


    // merge the IO writing and normal writing to SRAM, IO has higher priority.
    // merge the writing and reading, writing has higher priority.

    logic [RF_DEPTH-1:0][WORD_BITWIDTH-1:0] memory, memory_next;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            memory <= '{default: 0};
        end
        else begin
            memory <= memory_next;
        end
    end

    parameter WORD_PER_BULK = 2**(WORD_ADDR_WIDTH-BULK_ADDR_WIDTH);

    logic [AGU_BITWIDTH-1:0] stages, stages_next;
    logic [AGU_BITWIDTH-1:0] n_points;

    always_ff @(posedge clk or negedge rst_n) begin
        if (!rst_n) begin
            stages <= '0;
            n_points <= '0;
        end else begin
            if (fft_valid_1) begin
                stages <= stages_next;
                n_points <= n_points_1_0;
            end
        end
    end

    int i;
    always_comb begin
        stages_next = '0;
        for (i = AGU_BITWIDTH-1; i >= 0; i--) begin
            if (n_points[i]) begin
                stages_next = i;
                break;
            end
        end
    end

    logic [WORD_ADDR_WIDTH-BULK_ADDR_WIDTH-1:0] offset_w_addr, offset_r_addr;

    // LUT with bit reversed sequence for bulk address read
    typedef bit [AGU_BITWIDTH-1:0] LUT_t [RF_DEPTH];

    function LUT_t LUT_init();
        LUT_t temp;
        logic [AGU_BITWIDTH*2-1:0] ref_addr;
        int j;
        
        foreach (temp[i]) begin
            ref_addr = i << AGU_BITWIDTH;
            // Bit reversal
            for (j = 0; j < AGU_BITWIDTH; j++) begin
                temp[i][j] = ref_addr[stages - 1 - j + AGU_BITWIDTH];
            end
        end
        
        return temp;
    endfunction

    LUT_t bit_rev_addr;

    always_comb begin
        memory_next = memory;
        io_data_out = 0;
        word_data_out_1 = 0;
        word_data_out_2 = 0;
        word_data_out_3 = 0;
    
        // writing to io_data_in, otherwise word ports
        if (port_enable_0_2) begin
            for (int i=0; i<WORD_PER_BULK; i++) begin
                offset_w_addr = i;
                memory_next[{addr_0_2, offset_w_addr}] = io_data_in[i*WORD_BITWIDTH +:WORD_BITWIDTH];
            end
        end else begin
            if (port_enable_1_0) begin
                memory_next[addr_1_0] = word_data_in_1;
            end
            if (port_enable_2_0) begin
                memory_next[addr_2_0] = word_data_in_2;
            end
        end

        // reading from io_data_out, otherwise word ports
        if (port_enable_0_3) begin
            bit_rev_addr = LUT_init();
            for (int i=0; i<WORD_PER_BULK; i++) begin
                io_data_out[i*WORD_BITWIDTH +:WORD_BITWIDTH] = memory[bit_rev_addr[i+addr_0_3*WORD_PER_BULK]];
            end
        end else begin 
            if (port_enable_1_1) begin
                word_data_out_1 = memory[addr_1_1];
            end
            if (port_enable_2_1) begin
                word_data_out_2 = memory[addr_2_1];
            end
            if (port_enable_3_1) begin
                word_data_out_3 = memory[addr_3_1];
            end
        end
    end

    // IO
    assign io_en_in = port_enable_0_0;
    assign io_addr_in = addr_0_0;
    assign io_en_out = port_enable_0_1;
    assign io_addr_out = addr_0_1;

endmodule

